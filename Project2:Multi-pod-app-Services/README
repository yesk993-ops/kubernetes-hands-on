ğŸ“ Project Structure
project-2-multi-pod-services/
â”‚
â”œâ”€â”€ backend-configmap.yaml
â”œâ”€â”€ backend-deployment.yaml
â”œâ”€â”€ backend-service.yaml
â”‚
â”œâ”€â”€ frontend-configmap.yaml
â”œâ”€â”€ frontend-deployment.yaml
â”œâ”€â”€ frontend-service.yaml

ğŸ”¹ BACKEND APPLICATION
1ï¸âƒ£ Backend ConfigMap
ğŸ“Œ What is ConfigMap?

A ConfigMap stores:

Configuration files

App settings

Static content

â“ Why use it?

No need to rebuild images

Change config without touching containers

backend-configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: backend-html
data:
  index.html: |
    {
      "service": "backend",
      "message": "Hello from Kubernetes Backend API ğŸš€"
    }


Apply:

kubectl apply -f backend-configmap.yaml

2ï¸âƒ£ Backend Deployment
ğŸ“Œ What is a Deployment?

A Deployment:

Creates Pods

Maintains desired replica count

Restarts Pods if they crash

â“ Why use it?

Pods alone are fragile

Deployment gives self-healing + scaling

backend-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend-deployment
spec:
  replicas: 2        # Two backend pods
  selector:
    matchLabels:
      app: backend
  template:
    metadata:
      labels:
        app: backend
    spec:
      containers:
      - name: backend
        image: nginx:latest
        ports:
        - containerPort: 80
        volumeMounts:
        - name: backend-html
          mountPath: /usr/share/nginx/html
      volumes:
      - name: backend-html
        configMap:
          name: backend-html


Apply:

kubectl apply -f backend-deployment.yaml


Check:

kubectl get pods

3ï¸âƒ£ Backend Service (ClusterIP)
ğŸ“Œ What is a Service?

A Service:

Provides a stable IP & DNS name

Load balances traffic across Pods

â“ Why needed?

Pod IPs change when Pods restart.
Service solves this.

ğŸ“Œ What is ClusterIP?

Default Service type

Accessible only inside the cluster

â“ Why ClusterIP for backend?

Backend should NOT be exposed publicly

Only frontend should access it

backend-service.yaml
apiVersion: v1
kind: Service
metadata:
  name: backend-service
spec:
  type: ClusterIP
  selector:
    app: backend
  ports:
  - port: 80
    targetPort: 80


Apply:

kubectl apply -f backend-service.yaml


Test internally:

kubectl exec -it <frontend-pod> -- curl backend-service

ğŸ”¹ FRONTEND APPLICATION
4ï¸âƒ£ Frontend ConfigMap
ğŸ“Œ Purpose

Stores HTML + JavaScript that calls backend service.

â“ Why not hardcode backend IP?

Pod IPs change

Service name is DNS-resolved automatically

frontend-configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: frontend-html
data:
  index.html: |
    <!DOCTYPE html>
    <html>
    <body>
      <h1>Frontend App</h1>
      <button onclick="callBackend()">Call Backend</button>
      <pre id="output"></pre>

      <script>
        function callBackend() {
          fetch("http://backend-service")
            .then(res => res.text())
            .then(data => {
              document.getElementById("output").innerText = data;
            });
        }
      </script>
    </body>
    </html>


Apply:

kubectl apply -f frontend-configmap.yaml

5ï¸âƒ£ Frontend Deployment
ğŸ“Œ Why Deployment?

Same reason:

Scaling

Restart failed Pods

Rolling updates

frontend-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend-deployment
spec:
  replicas: 2
  selector:
    matchLabels:
      app: frontend
  template:
    metadata:
      labels:
        app: frontend
    spec:
      containers:
      - name: frontend
        image: nginx:latest
        ports:
        - containerPort: 80
        volumeMounts:
        - name: frontend-html
          mountPath: /usr/share/nginx/html
      volumes:
      - name: frontend-html
        configMap:
          name: frontend-html


Apply:

kubectl apply -f frontend-deployment.yaml

6ï¸âƒ£ Frontend Service (NodePort)
ğŸ“Œ What is NodePort?

Exposes Service on a node port

Allows browser access from your machine

â“ Why NodePort?

Simple for local learning

In production, replaced by LoadBalancer/Ingress

frontend-service.yaml
apiVersion: v1
kind: Service
metadata:
  name: frontend-service
spec:
  type: NodePort
  selector:
    app: frontend
  ports:
  - port: 80
    targetPort: 80
    nodePort: 30008


Apply:

kubectl apply -f frontend-service.yaml

ğŸŒ Access Application
minikube ip


Open:

http://<MINIKUBE-IP>:30008


Click Call Backend
âœ” Backend response appears

ğŸ§  CRITICAL Kubernetes CONCEPTS YOU MASTERED
ğŸ”¹ Service Discovery

backend-service resolves via DNS

No hardcoded IPs

ğŸ”¹ Load Balancing

Service distributes traffic across Pods

ğŸ”¹ Self Healing

Delete Pod â†’ Deployment recreates

ğŸ”¹ Isolation

Backend is internal

Frontend is public

ğŸ§ª Mandatory Practice (DO THESE)

Scale backend:

kubectl scale deployment backend-deployment --replicas=4


Delete backend Pods manually

Rename backend-service â†’ fix frontend

